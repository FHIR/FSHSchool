[{"body":"Step 1: Install Node.js GoFSH requires Node.js. To install Node.js, go to https://nodejs.org/ and select the “LTS” download. If the download is not appropriate for your operating system, click the “Other Downloads” link to get a full list of downloads. Once the installer is downloaded, run it using the default options.\nEnsure that Node.js is correctly installed by opening a command window and typing the following two commands. Each command should return a version number.\n node --version  npm --version Step 2: Install GoFSH To install GoFSH, open up a command prompt and type the following command:\n npm install -g gofsh Check the installation via the command below:\n gofsh --help If the command outputs instructions on using the GoFSH command line interface (CLI), you’re ready to run GoFSH.\nUse gofsh -v to display the installed version of GoFSH and the version of the FSH specification it supports. GoFSH follows the semantic versioning convention (MAJOR.MINOR.PATCH):\n MAJOR: A major release has significant new functionality and, potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatibility within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatibility within the major version.  Updating or Reverting GoFSH To update GoFSH to the latest version, re-run:\n npm install -g gofsh To revert to a previous version of GoFSH, run:\n npm install -g gofsh@{version} where the {version} is replaced by the desired MAJOR.MINOR.PATCH version (e.g., npm install -g gofsh@1.5.0).\n","excerpt":"Step 1: Install Node.js GoFSH requires Node.js. To install Node.js, go …","ref":"/docs/gofsh/installation/","title":"Installation"},{"body":"Step 1: Install Node.js SUSHI requires Node.js. To install Node.js, go to https://nodejs.org/ and select the “LTS” download. If the download is not appropriate for your operating system, click the “Other Downloads” link to get a full list of downloads. Once the installer is downloaded, run it using the default options.\nEnsure that Node.js is correctly installed by opening a command window and typing the following two commands. Each command should return a version number.\n node --version  npm --version Step 2: Install SUSHI To install SUSHI, open up a command prompt and type the following command:\n npm install -g fsh-sushi Check the installation via the command below:\n sushi help If the command outputs instructions on using the SUSHI command line interface (CLI), you’re ready to run SUSHI.\nUse sushi -v to display the installed version of SUSHI and the version of the FSH specification it supports. SUSHI follows the semantic versioning convention (MAJOR.MINOR.PATCH):\n MAJOR: A major release has significant new functionality and, potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatibility within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatibility within the major version.  Tip For the most up-to-date information and latest releases of SUSHI, check the release history and release notes.  Reverting SUSHI To revert to a previous version of SUSHI, run:\n npm install -g fsh-sushi@{version} where the {version} is replaced by the desired MAJOR.MINOR.PATCH version (e.g., npm install -g fsh-sushi@2.2.6).\n","excerpt":"Step 1: Install Node.js SUSHI requires Node.js. To install Node.js, go …","ref":"/docs/sushi/installation/","title":"Installation"},{"body":"Minimal Project The simplest FSH project contains only a configuration file and an input/fsh subdirectory of FSH files containing FHIR Shorthand definitions. It might look like this:\nmy-project ├── input | └── fsh | ├── file1.fsh | ├── file2.fsh | └── file3.fsh └── sushi-config.yaml Each FSH file can contain multiple FSH definitions of varying types. FSH file names are not significant, but must end with the .fsh extension. In addition, FSH files can be organized into subdirectories. This provides authors the flexibility to organize their FSH definitions in whatever way makes sense to then.\nThe sushi-config.yaml file provides project configuration data to SUSHI. It is described further in the Configuration documentation.\nInitializing a SUSHI Project Setting up a fully-featured FSH project can be complex, so SUSHI provides an init command to do it automatically. When sushi init is run, SUSHI will request project information from the user:\nName (Default: ExampleIG): my-project Id (Default: fhir.example): my.id Canonical (Default: http://example.org): http://myid.org Status (Default: draft): active Version (Default: 0.1.0): 2.0.0 Release Label (Default: ci-build): trial-use Publisher Name (Default: Example Publisher): MyPublisher Publisher Url (Default: http://example.org/example-publisher): http://my-publisher.org Initialize SUSHI project in C:\\Users\\shorty\\dev\\my-project? [y/n]: y These values are then used to generate a project structure compatible with the FHIR IG Publisher:\nmy-project ├── .gitignore ├── _genonce.bat ├── _genonce.sh ├── _updatePublisher.bat ├── _updatePublisher.sh ├── ig.ini ├── input | ├── ignoreWarnings.txt | ├── fsh | | └── patient.fsh | └── pagecontent | └── index.md └── sushi-config.yaml In addition to the input/fsh folder, init creates an input/pagecontent folder containing a dummy home page for your IG. The files ig.ini and ignoreWarnings.txt are required by the template-based IG Publisher. The .bat and .sh scripts which allow you to run the IG Publisher from your command line. Finally, a default .gitignore file for integration with GitHub is provided. From this point on, you can modify the configuration and definitions as necessary.\nUsing the HL7 IG Publisher and Auto-Builder This project structure integrates with the HL7 IG Publisher Auto-Builder. When the IG Publisher detects an input/fsh subdirectory, it will automatically run SUSHI on the project directory and output the SUSHI results to a fsh-generated directory (e.g., my-project/fsh-generated in the example above). It will then continue with the normal IG Publisher process.\nThis approach allows a GitHub repository to be configured such that whenever changes to FSH files are pushed to GitHub, the Auto-Builder will pick them up, run the SUSHI/IG Publisher process, and publish the resulting IG to http://build.fhir.org.\nSUSHI provides support for several of the files and directories required by the template-based IG Publisher for building Implementation Guides. Some IG customizations can be configured using additional properties in the sushi-config.yaml file. A FSH project integrated into the template-based IG Publisher may look like this:\nmy-project ├── ig.ini ├── input | ├── fsh | | ├── file1.fsh | | ├── file2.fsh | | └── file3.fsh │ ├── ignoreWarnings.txt │ ├── images │ │ ├── myDocument.pdf │ │ ├── myGraphic.png │ │ └── mySpreadsheet.xlsx │ ├── includes │ │ └── menu.xml │ └── pagecontent │ ├── 1_mySecondPage.md │ ├── 2_myThirdPage.md │ ├── 3_myFourthPage.md │ └── index.md ├── package-list.json ├── sushi-ignoreWarnings.txt └── sushi-config.yaml  Tip Examples of package.json, ig.ini, package-list.json, ignoreWarnings.txt and menu.xml files can be found in the sample IG project provided for this purpose. In addition, more general guidance can be found in Guidance for HL7 IG Creation.  You can populate your project as follows:\n  sushi-config.yaml: This file provides configuration data to SUSHI. It is described further in the Configuration documentation.\n  input/fsh/*.fsh: FSH files contain the FHIR Shorthand definitions for all the resources and examples in your IG.\n  ig.ini: Configuration file required for the FHIR IG Publication process. NOTE: As of the SUSHI 1.0 release, this file MUST use a template based on fhir.base.template#current. Specific template versions (i.e., other than #current) are expected to work in the future. For now, any of the following should work:\n template = fhir.base.template#current template = hl7.base.template#current template = hl7.fhir.template#current template = hl7.davinci.template#current template = hl7.cda.template#current    input/ignoreWarnings.txt: This file is used to suppress specific QA warnings and information messages produced by the FHIR IG Publisher (as opposed to SUSHI).\n  input/images/*: Put anything that is not a page in the IG, such as images, spreadsheets or zip files, in the input/images subdirectory. These files can be referenced by user-provided pages or menus.\n  input/includes/menu.xml: If present, this file will be used for the IG’s main menu layout. Note that the presence of this file will block usage of the menu property in sushi-config.yaml.\n  input/pagecontent/*: Put either markup (.xml) or markdown (.md) files with the narrative content of your IG in the input/pagecontent/ subdirectory. These files are the sources for the html pages that accompany the automatically-generated pages of your IG. The header and footer of these pages are automatically generated, so your content should not include these elements. Any number of pages can be added. In addition to stand-alone pages, you can provide additional text for generated artifact pages. The naming of these files is significant:\n index.xml|md: This file provides the content for the IG’s main page. N_pagename.xml|md: If present, these files will be generated as individual pages in the IG. The leading integer (N) determines the order of the pages in the table of contents. Adding a leading integer is optional, and in the absence of a leading integer, SUSHI will sort the pages alphabetically. The order of the pages can also be explitly specified with the pages property in sushi-config.yaml. {artifact-file-name}-intro.xml|md: If present, the contents of the file will be placed on the relevant page before the artifact’s definition. {artifact-file-name}-notes.xml|md: If present, the contents of the file will be placed on the relevant page after the artifact’s definition.    input/{supported-resource-input-directory}/* (not shown above): JSON or XML files in supported resource directories (e.g., profiles, extensions, examples, etc.) can be referenced by FHIR artifacts defined in FSH, and will be added to the generated ImplementationGuide.json file. If there are additional subfolders (e.g., input/resources/nested), use the path-resource parameter in sushi-config.yaml to tell the IG Publisher which additional input paths to process (see Specifying Additional Resource Paths for details).\n  package-list.json: This optional file, described here, should contain the version history of your IG.\n  sushi-ignoreWarnings.txt: This optional file can be used to suppress warnings logged by SUSHI. Errors and informational logs from SUSHI cannot be ignored. This file should be placed either at the root of the project (e.g., my-project/sushi-ignoreWarnings.txt in the example above), or within the input directory (e.g., my-project/input/sushi-ignoreWarnings.txt). Warnings will be ignored if they completely match the contents of any line of the file (one line per warning, case-sensitive). Regular expressions can also be specified, one per line, indicated by starting and ending the line with /. For example:\nInstance PatientExample1 is not an instance of a resource, so it should only be used inline on other instances, and it will not be exported to a standalone file. Specify \"Usage: #inline\" to remove this warning. /Detected the following non-conformant Resource definitions.*/ Any warning which exactly matches the contents of the first line will be ignored. The second line specifies that any warning beginning with Detected the following non-conformant Resource definitions will be ignored.\nTip SUSHI does log several multi-line warnings, but these warnings cannot be specified directly in the sushi-ignoreWarnings.txt file, since the warnings to ignore must be specified line by line. To ignore these warnings, a regular expression should be used.    ","excerpt":"Minimal Project The simplest FSH project contains only a configuration …","ref":"/docs/sushi/project/","title":"Project Structure"},{"body":"For more information on FHIR, FSH, and SUSHI, please see the documentation home page.\n","excerpt":"For more information on FHIR, FSH, and SUSHI, please see the …","ref":"/docs/sushi/","title":"SUSHI"},{"body":"Using GoFSH, you can turn an existing FHIR Implementation Guide into a FSH project automatically.\nIf you are starting a project from scratch, see Initializing a SUSHI Project.\nFor more information on FHIR, FSH, and SUSHI, please see the documentation home page.\n","excerpt":"Using GoFSH, you can turn an existing FHIR Implementation Guide into a …","ref":"/docs/gofsh/","title":"GoFSH"},{"body":"SUSHI is configured by a single sushi-config.yaml file. This file is written using YAML. Authors unfamiliar with YAML should note that:\n White space (new lines and indentation) is significant Information is presented in key: value pairs Strings do not have to be quoted unless they contain reserved characters, such as colon (:) Arrays/sequences are created using -  FSH Only: Minimum Configuration If an author does not have an ImplementationGuide resource, and wants SUSHI to build FHIR definition files and not to do any additional IG processing, the author should create a sushi-config.yaml with the keys FSHOnly (with value true), canonical, and fhirVersion. For example:\nFSHOnly:truefhirVersion:4.0.1canonical:http://hl7.org/fhir/us/exampleThe sushi-config.yaml file should be located in the project’s root folder.\nFSH Only: Existing ImplementationGuide Resource If an author wants SUSHI only to build the FHIR definition files and not to do any additional IG processing, AND the project contains an ImplementationGuide resource, then the author does not need to provide a sushi-config.yaml file. If there is no sushi-config.yaml file, SUSHI will attempt to extract the following information from the ImplementationGuide resource:\n id canonical url name packageId fhirVersion version dependencies parameters  SUSHI will then run in FSHOnly mode to produce FHIR definition files only.\nTo locate the ImplementationGuide resource, SUSHI assumes the project structure required by the template-based IG Publisher, and uses the following approach:\n Look for \u003croot\u003e/ig.ini, where \u003croot\u003e is the folder containing the input folder. If the ig.ini file exists, it will have an ig property which gives the path to the ImplementationGuide resource, so SUSHI will use this path to find the resource. If there is no ig.ini in the root folder, SUSHI will search the \u003croot\u003e/input folder for an ImplementationGuide resource, and if exactly one resource is found, SUSHI will extract the above properties from it.  FSH and IG Processing: Minimum Configuration If the author wants SUSHI to do additional Implementation Guide (IG) processing, then the sushi-config.yaml file must provide some metadata values for the FSH project. Here is an example of a minimal configuration:\nid:fhir.us.examplecanonical:http://hl7.org/fhir/us/examplename:ExampleIGstatus:draftversion:0.1.0fhirVersion:4.0.1copyrightYear:2020+releaseLabel:ci-build Download Minimum Configuration Example\n For an official HL7 project, the id and canonical will typically be assigned by the FHIR Product Director. canonical refers to the canonical base of the IG, not the canonical URL of the IG resource (e.g., http://hl7.org/fhir/us/example, not http://hl7.org/fhir/us/example/ImplementationGuide/fhir.us.example). Valid values for status include:  draft: The IG is still under development and is not yet considered to be ready for normal use. active: The IG is ready for normal use. retired: The IG has been withdrawn or superseded and should no longer be used. unknown: It is not know which of the status values currently applies for the IG. This should be rare.   Since SUSHI currently supports only FHIR R4 and R5, the fhirVersion should always be 4.0.0 or above. releaseLabel is a text label with no fixed set of values that describes the status of the publication to users. Recommended best practices include the following values, optionally suffixed with Ballot:  ci-build STU1, STU2, etc. STU 1.1, STU 1.1.0, etc. Normative 1, etc. Informative 1, etc.    Tip SUSHI can generate a simple configuration file for you with the init command  FSH and IG Processing: Recommended Configuration In addition to the minimum configuration requirements shown above, most IG authors will also want to provide a title, description, license, publisher, and dependencies:\nid:fhir.us.examplecanonical:http://hl7.org/fhir/us/examplename:ExampleIGtitle:\"HL7 FHIR Implementation Guide: Example IG Release 1 - US Realm | STU1\"description:AnexampleIGthatexercisesmanyofthefieldsinaSUSHIconfigurationstatus:draftlicense:CC0-1.0version:0.1.0fhirVersion:4.0.1copyrightYear:2020+releaseLabel:ci-buildpublisher:name:HL7International- USRealmSteeringCommitteeurl:http://www.hl7.org/Special/committees/usrealm/index.cfmemail:usrsc@lists.HL7.orgdependencies:hl7.fhir.us.core:3.1.0 Download Recommended Configuration Example\nNote The license value should come from the SPDX Licence Value Set, although most FHIR IGs use the CC0-1.0 (Creative Commons Zero v1.0 Universal) license.  Dependencies The dependencies value is a YAML object for which the keys are each dependency’s package id and the values are the dependency versions. The typical format is:\ndependencies:hl7.fhir.us.core:3.1.0In addition to standard version identifiers, the following three special versions are supported:\n dev: indicates that the dependency should be loaded from the local FHIR cache current: indicates that the dependency should be loaded from the last successful auto-build. latest: indicates that the dependency should be loaded using the version tagged as latest on the package server.  The dependencies property also supports an advanced syntax that allows you to directly specify the dependency id and/or URI if necessary. For example:\ndependencies:hl7.fhir.us.core:id:uscoreuri:http://hl7.org/fhir/us/core/ImplementationGuide/hl7.fhir.us.coreversion:3.1.0SUSHI also supports extensions for converting between versions of FHIR. To get extensions that represent elements from other versions of FHIR, a package of the form hl7.fhir.extensions.\u003cextension-version\u003e:\u003cpackage-version\u003e is used. The \u003cextension-version\u003e should be one of r2, r3, or r4 to indicate which version of FHIR the element represented by the extension is defined in. The \u003cpackage-version\u003e represents which version of FHIR the extension will be used in. For an IG defined using FHIR R4, this would be 4.0.1. As an example, if an author wanted to represent the Patient.animal.species element as defined in R3, the dependencies should be specified as:\ndependencies:hl7.fhir.extensions.r3:4.0.1An author can then reference the extension using a URL following the format defined in the FHIR specification linked above. For example, the extension referring to the R3 Patient.animal.species element would be: http://hl7.org/fhir/3.0/StructureDefinition/extension-Patient.animal.species.\nFSH and IG Processing: Full Configuration The table below lists all configuration properties that can be used in SUSHI’s sushi-config.yaml file. Most SUSHI configuration properties come directly from the Implementation Guide resource and will be translated into the generated ImplementationGuide resource for your project. Differences between the sushi-config.yaml properties and ImplementationGuide properties are noted below.\n   Property Corresponding IG element Usage     applyExtensionMetadataToRoot N/A When set to true, the “short” and “definition” field on the root element of an Extension will be set to the “Title” and “Description” of that Extension. Default is true.   canonical N/A The canonical base URL to be used throughout the IG   contact contact As specified in the IG resource   contained contained As specified in the IG resource   copyright copyright As specified in the IG resource   copyrightLabel copyrightLabel As specified in the IG resource - Note: this is an R5 IG element   copyrightYear or copyrightyear N/A Used to add a copyrightyear parameter to IG.definition.parameter   date date As specified in the IG resource   definition └ extension definition.extension A list of extensions that apply to IG.definition. Note: the only property supported on the definition property is extension.   description description As specified in the IG resource   dependencies dependsOn A key: value pair, where key is the package id and value is the version (or dev/current). For advanced use cases, the value can be an object with keys for id, uri, version, and extension. For R5 IG resources, the key reason can also be provided.   experimental experimental As specified in the IG resource   extension extension As specified in the IG resource   fhirVersion fhirVersion As specified in the IG resource. SUSHI supports FHIR versions in the R4 or R5 sequences, as given in the FHIR Publication History. 5.0.0-snapshot1. Projects that wish to use a 5.0.0 pre-release can specify the version in their sushi-config.yaml file, e.g., fhirVersion: 5.0.0-snapshot1.   FSHOnly N/A When this flag is set to true, no IG-specific content will be generate. SUSHI will only convert FSH definitions to JSON files. The author at least needs to provide a canonical and fhirVersion for FSHOnly processing to succeed. When FSHOnly is false or unspecified, IG content is generated.   global global Key is the type and value is the profile   groups definition.grouping A key: value pair, where key is the group id and value is the description of the group. For advanced use cases, the value can be an object with keys for name, description, and resources. See the Exhaustive Example for details.   id id As specified in the IG resource   implicitRules implicitRules As specified in the IG resource   instanceOptions N/A key: value pairs, where keys are setId, setMetaProfile, and manualSliceOrdering. The setId value controls whether id is set on generated instances. Options are always (set id on all instances [the default]) or standalone-only (set id for instances where the Usage keyword is NOT #inline).The setMetaProfile value controls whether meta.profile is set on generated instances. It can have the following values: always (set meta.profile for all instances [the default]), never (do not set meta.profile on any instances), inline-only (set meta.profile only for instances of profiles with Usage keyword set to #inline), or standalone-only (set meta.profile for instances where the Usage keyword is NOT #inline).The manualSliceOrdering value controls whether slice ordering is determined exclusively by the order in which slices are referenced in an instance’s FSH rules. When this flag is set to true, manual ordering is enabled (see Manual Slice Ordering).   jurisdiction jurisdiction As specified in the IG resource   language language As specified in the IG resource   license license As specified in the IG resource   menu N/A Used to generate the fsh-generated/includes/menu.xml file. The key is the menu item name and the value is the URL. Menus can contain sub-menus, but the IG Publisher currently only supports sub-menus one level deep. See the Exhaustive Example for details. Authors can provide their own menu.xml by removing this property and placing a menu.xml file in /input/includes.   meta meta As specified in the IG resource   modifierExtension modifierExtension As specified in the IG resource   name name As specified in the IG resource   packageId packageId As specified in the IG resource. If unspecified, defaults to id.   pages definition.page SUSHI can auto-generate pages, but authors can manage pages through this property. If this property is used, SUSHI will not generate any page entries. The YAML key is the file name containing the page. The title key-value pair provides the title for the page. If a title is not provided, then the title will be generated from the file name. If a generation value (corresponding to definition.page.generation) is not provided, it will be inferred from the file name extension. In the IG resource, pages can contain sub-pages; so in the config file, any sub-properties that are valid filenames with supported extensions (e.g., .md/.xml) will be treated as sub-pages. See the Exhaustive Example for details.   parameters definition.parameter Consists of key-value pairs where the keys are values of definition.parameter.code. For R5 IG resources, the key can be a FSH code that specifies the code and system values of definition.parameter.code, which is a Coding. See the Exhaustive Example for details. If a parameter allows repeating values, the value in the YAML may be a sequence/array. For example, the path-resource parameter specifies relative paths to additional folders that contain predefined resources (see Specifying Additional Resource Paths).   publisher publisher, with cardinality changed to 0..* Publisher can be a single item or a list, each with a name and optional url and/or email. The first publisher’s name will be used as IG.publisher. The contact details and/or additional publishers will be translated into IG.contact values   releaseLabel or releaselabel N/A Used to add a releaseLabel parameter to IG.definition.parameter   resources definition.resource SUSHI can auto-generate a list of resources based on FSH definitions and provided JSON or XML resources, but this property can be used to add additional entries or override generated entries. SUSHI uses the {resource type}/{resource name} format as the YAML key (corresponding to IG.definition.resource.reference). Authors can specify the value “omit” to omit a FSH-generated resource from the resource list. groupingId can be used, but top-level groups syntax may be a better option.   status status As specified in the IG resource   templates definition.template As specified in the IG resource   text text As specified in the IG resource   title title As specified in the IG resource   url url As specified in the IG resource. If unspecified, defaults to {canonical}/ImplementationGuide/{id}.   useContext useContext As specified in the IG resource   version version As specified in the IG resource   versionAlgorithmString versionAlgorithm[x] As specified in the IG resource - Note: this is an R5 IG element   versionAlgorithmCoding versionAlgorithm[x] As specified in the IG resource - Note: this is an R5 IG element    Exhaustive Example The following provides an exhaustive example sushi-config.yaml covering many of the properties discussed above.\n# This IG YML file is inspired by the ImplementationGuide resource# and also draws from package.json, package-list.json, and ig.ini.# That said, it is structured for ease-of-use, so it is not strictly# conformant to any of those existing configuration formats.# SUSHI will use id as both id and packageId in the IG unless a# specific packageId is also provided in this file.id:fhir.us.examplecanonical:http://hl7.org/fhir/us/exampleurl:http://hl7.org/fhir/us/example/ImplementationGuide/fhir.us.examplename:ExampleIGtitle:\"HL7 FHIR Implementation Guide: Example IG Release 1 - US Realm | STU1\"description:ExampleIGexercisesmanyofthefieldsinaSUSHIconfiguration.status:activelicense:CC0-1.0date:2020-02-26version:1.0.0# Although fhirVersions is 0..* in the ImplementationGuide resource# it can be a single item OR and array here (but so far SUSHI only# supports 4.0.1 anyway).fhirVersion:4.0.1# The following two lines correspond to items that used to be in# ig.ini but were moved to IG.definition.parameter. For# consistency within this file, the names are represented using# camelcase, but if authors use the formal parameter names, SUSHI# will recognize them as well. In either case, they'll be copied# to the IG JSON using the formal names.copyrightYear:2019+releaseLabel:STU1# The publisher can be a single item or a list, each with a name and# optional url and/or email. The first publisher's name will be used# as IG.publisher. The contact details and/or additional publishers# will be translated into IG.contact values.publisher:name:HL7FHIRManagementGroupurl:http://www.hl7.org/Special/committees/fhirmgemail:fmg@lists.HL7.org# Those who need more control or want to add additional details to the contact values can use# contact directly and follow the format outlined in the ImplementationGuide resource and# ContactDetail.contact:- name:BobSmithtelecom:- system:emailvalue:bobsmith@example.orguse:work# The jurisdiction can be a single item or a list. The FHIR Shorthand# code syntax can be used here.jurisdiction:urn:iso:std:iso:3166#US \"United States of America\"# The dependencies property corresponds to IG.dependsOn. The key is the# package id and the value is the version (or dev/current). For advanced# use cases, the value can be an object with keys for `uri` and `version`.# For R5 ImplementationGuides, the object can also have a key for `reason`.dependencies:hl7.fhir.us.core:3.1.0hl7.fhir.us.mcode:id:mcodeuri:http://hl7.org/fhir/us/mcode/ImplementationGuide/hl7.fhir.us.mcodeversion:1.0.0# The global property corresponds to the IG.global property, but it# uses the type as the YAML key and the profile as its value. Since# FHIR does not explicitly disallow more than one profile per type,# neither do we; the value can be a single profile URL or an array# of profile URLs.global:Patient:http://example.org/fhir/StructureDefinition/my-patient-profileEncounter:http://example.org/fhir/StructureDefinition/my-encounter-profile# NOTE: All of the properties of IG.definition are abstracted to# individual top-level configuration properties (below). This# definition property should only be used to provide extensions# that have a context of IG.definition.definition:extension:- url:http://example.org/example/ig-definition-extvalueBoolean:true# The resources property corresponds to IG.definition.resource.# SUSHI can auto-generate all of the resource entries based on# the FSH definitions and/or information in any user-provided# JSON or XML resource files. If the generated entries are not# sufficient or complete, however, the author can add entries# here. If a generated entry matches the reference, it will# not be added to SUSHI output. The format follows IG.definition.resource# with the following differences:# * use IG.definition.resource.reference.reference as the YAML key# * specify \"omit\" to omit a FSH-generated resource from the# resource list.# * groupingId can be used, but top-level groups syntax may be a# better option (see below).# The following are simple examples to demonstrate what this might# look like:resources:Patient/my-example-patient:name:MyExamplePatientdescription:AnexamplePatientexampleBoolean:truePatient/bad-example:omit# For R5 ImplementationGuides, the example[x] property was replaced# with isExample. A profile property is also included. These can be# specified directly in configuration. Profile can be a single item# or an array.# An example resources configuration for an R5 ImplementationGuide:# resources:# Patient/my-example-patient:# name: My Example Patient# description: An example Patient# isExample: true# profile: http://example.org/fhir/StructureDefinition/my-patient-profile# Groups can control certain aspects of the IG generation. The IG# documentation recommends that authors use the default groups that# are provided by the templating framework, but if authors want to# use their own instead, they can use the mechanism below. This will# create IG.definition.grouping entries and associate the individual# resource entries with the corresponding groupIds.groups:GroupA:name:GroupAdescription:TheAlphaGroupresources:- StructureDefinition/animal-patient- StructureDefinition/arm-procedureGroupB:name:GroupBdescription:TheBetaGroupresources:- StructureDefinition/bark-control- StructureDefinition/bee-sting# The pages property corresponds to IG.definition.page. SUSHI can# auto-generate the page list, but if the author includes pages in# this file, it is assumed that the author will fully manage the# pages section and SUSHI will not generate any page entries.# The page file name is used as the key. If title is not provided,# then the title will be generated from the file name. If a# generation value is not provided, it will be inferred from the# file name extension. Any subproperties that are valid filenames# with supported extensions (e.g., .md/.xml) will be treated as# sub-pages.## For R5 ImplementationGuides, the IG.definition.page element now# supports a source[x] element. SUSHI will generate sourceUrl# based on the name if it is not provided. To provide a source,# add a key/value pair subproperty with the type slice as the key.pages:index.md:title:ExampleHomeimplementation.xml:examples.xml:title:ExamplesOverviewsimpleExamples.xml:complexExamples.xml:# The ImplementationGuide resource defines several other properties# not represented above. These properties can be used as-is and# should follow the format defined in ImplementationGuide:# * meta# * implicitRules# * language# * text# * contained# * extension# * modifierExtension# * experimental# * useContext# * copyright# * packageId# The R5 ImplementationGuide resource defines additional properties# not represented above. These properties can be used as-is and# should follow the format defined in ImplementationGuide:# * copyrightLabel# * versionAlgorithm[x], which should be specified with the type slice (e.g. versionAlgorithmString)# The menu property will be used to generate the input/menu.xml file.# The menu is represented as a simple structure where the YAML key# is the menu item name and the value is the URL. The IG publisher# currently only supports one level deep on sub-menus.# To provide a custom menu.xml file, do not include this property and# include a `menu.xml` file in input/includes.menu:Home:index.htmlArtifacts:Profiles:artifacts.html#2Extensions:artifacts.html#3Value Sets:artifacts.html#4Downloads:downloads.htmlHistory:http://hl7.org/fhir/us/example/history.html# The parameters property represents IG.definition.parameter. Rather# than a list of code/value pairs (as in the ImplementationGuide# resource), the code is the YAML key. If a parameter allows repeating# values, the value in the YAML should be a sequence/array. For parameters# defined by core FHIR see: http://build.fhir.org/codesystem-guide-parameter-code.html.# For parameters defined by the FHIR Tools IG see:# http://build.fhir.org/ig/FHIR/fhir-tools-ig/branches/master/CodeSystem-ig-parameters.htmlparameters:excludettl:truevalidation:[allow-any-extensions,no-broken-links]show-inherited-invariants:false# For R5 ImplementationGuides, the IG.definition.parameter.code became a Coding.# In this case, the YAML key becomes the code.code. If the code provided is in the# value set bound in the IG definition (see: http://hl7.org/fhir/2022Sep/valueset-guide-parameter-code.html),# that system is automatically set. If no system is provided, SUSHI will default the system# to the system for the IG Parameter Codes# (see: http://build.fhir.org/ig/FHIR/fhir-tools-ig/branches/master/CodeSystem-ig-parameters.html).# To use a different system, the YAML key can be a FSH code.# An example parameters configuration for an R5 ImplementationGuide:# parameters:# generate-xml: true# validation: [allow-any-extensions, no-broken-links]# http://example.org/fhir/other-system#example: false# The FSHOnly flag indicates if only FSH resources should be exported.# If set to true, no IG related content will be generated.# The default value for this property is false.FSHOnly:false# When set to true, the \"short\" and \"definition\" field on the root element of an Extension will# be set to the \"Title\" and \"Description\" of that Extension. Default is true.applyExtensionMetadataToRoot:false# The instanceOptions property is used to configure certain aspects of how SUSHI processed instances.# See the individual option definitions below for more detail.instanceOptions:# Determines for which types of Instances SUSHI will automatically set meta.profile# if InstanceOf references a profile. Options are:# - always: Set meta.profile for all Instances of profiles (default)# - never: Do not set meta.profile on any Instances# - inline-only: Set meta.profile for only Instances of profiles with Usage set to #inline# - standalone-only: Set meta.profile for only Instances of profiles where Usage is any value other than #inlinesetMetaProfile:always# Determines for which types of Instances SUSHI will automatically set id# if InstanceOf references a profile. Options are:# - always: Set id for all Instances (default)# - standalone-only: Set id for only Instances where Usage is any value other than #inlinesetId:always# When set to true, slices must be referred to by name and not only by a numeric index in order to be used# in an Instance's assignment rule. All slices appear in the order in which they are specified in FSH rules.manualSliceOrdering:true Download Exhaustive Configuration Example\n","excerpt":"SUSHI is configured by a single sushi-config.yaml file. This file is …","ref":"/docs/sushi/configuration/","title":"Configuration"},{"body":" Note This documentation assumes you have a SUSHI-compliant project structure and configuration as discussed in the previous sections.  Running SUSHI SUSHI is executed from the command line. The general form of the SUSHI execution command is as follows:\n sushi {command} {options} Supported commands are build, init, update-dependencies, and help.\nUse sushi --version to get basic information about the current SUSHI version. Use sushi help to get basic information about SUSHI, and use sushi help {command} to get information about a specific command and its options (e.g., sushi help build).\nSUSHI Commands SUSHI provides various commands to use with FSH projects. The following sections provide more details on each.\nbuild The build command is used to build a SUSHI project. In SUSHI 2.x, it is the default command and can be used as follows:\n sushi build {fsh-project-directory} {options} where options include the following (in any order):\n-l, --log-level \u003clevel\u003e specify the level of log messages (default: \"info\") (choices: \"error\", \"warn\", \"info\", \"debug\") -o, --out \u003cout\u003e the path to the output folder (default: \"fsh-generated\") -p, --preprocessed output FSH produced by preprocessing steps -r, --require-latest exit with error if this is not the latest version of SUSHI (default: false) -s, --snapshot generate snapshot in Structure Definition output (default: false) -c, --config \u003cconfig\u003e override elements in sushi-config.yaml (supported: 'version', 'status', 'releaselabel') (eg: --config status:draft) -h, --help display help for command Further information about each option can be found in Build Command Option Details.\nTip If you run SUSHI from your FSH project directory, and accept the defaults, the command can be shortened to sushi build . or simply sushi build.  init The init command is used to generate a project structure that is compatible with the FHIR IG Publisher. In SUSHI 2.x, it can be used as follows:\n sushi init Further details on how to use this command can be found in Initializing a SUSHI Project.\nupdate-dependencies The update-dependencies command is used to update the FSH project’s dependencies to the latest version. The command will check all dependencies defined in the sushi-config.yaml file to see if they are at the latest published version. SUSHI will output a list of all dependencies that have later versions and prompt the author whether to update. Choosing to update will directly modify the sushi-config.yaml file with the latest version and download the latest version of the dependency to the FHIR cache. Any dependency with a current or dev version will not be modified. This command can be used as follows:\n sushi update-dependencies {fsh-project-directory} Build Command Option Details The following sections give further detail on using certain command line options.\n--out The --out or -o flag specifies where SUSHI’s output, the fsh-generated folder, should be written. By default, the folder will be written to the root folder, i.e., parallel to the input folder. When SUSHI begins, any existing content in the designated location is deleted. Within the fsh-generated folder, SUSHI generates file names based on the resource id (i.e., ${resourceType}-${resourceId}.json). If the id contains one or more path separators, SUSHI will sanitize file names to assure all files are written to the target directory. (Note: the --out option does not refer to the output folder written by the IG Publisher).\n--preprocessed The --preprocessed or -p flag can be used to to create a folder named _preprocessed in SUSHI’s output folder. This folder will contain representations of the input FSH after several preprocessing steps have taken place. These steps include resolution of Alias values, insertion of RuleSet rules, and resolution of soft indexing. This is mainly provided as a debugging tool, for the author to verify that SUSHI is preprocessing the input FSH in an expected way, and to help trace errors in the output of SUSHI back to their source. For example, if the IG Publisher reports an error on element Bundle.entry[56].resource, it may be difficult to identify the problematic entry in your FSH source if you used soft-indexing. It is much easier, however, to identify the problematic element in the preprocessed FSH that contains explicit indices.\nThe example below shows a FSH snippet and a preprocessed version of that snippet. In this snippet, a Profile is defined using a RuleSet and an Alias, and below an Instance is defined which uses soft indexing.\nAlias: $CAT = http://hl7.org/fhir/ValueSet/observation-category Profile: ObservationProfile Parent: Observation * insert Metadata * category from $CAT (required) RuleSet: Metadata * ^version = \"1.2.3\" * ^publisher = \"Example publisher\" Instance: PatientInstance InstanceOf: Patient * name.given[+] = \"John\" * name.given[+] = \"Q\" The preprocessed version of the above FSH is shown below. The $CAT alias has been resolved to its full URL, the rules contained in the RuleSet have been inserted onto the ObservationProfile, and the RuleSet itself has been removed, and the rules on the PatientInstance have been resolved to fully specified paths, which do not use soft indexing.\nAlias: $CAT = http://hl7.org/fhir/ValueSet/observation-category // Originally defined on lines 3 - 6 Profile: ObservationProfile Parent: Observation Id: ObservationProfile * ^version = \"1.2.3\" * ^publisher = \"Example publisher\" * category from http://hl7.org/fhir/ValueSet/observation-category (required) // Originally defined on lines 12 - 15 Instance: PatientInstance InstanceOf: Patient Usage: #example * name.given[0] = \"John\" * name.given[1] = \"Q\"  Note Once you have finished reviewing your preprocessed FSH, we recommend deleting the _preprocessed folder to avoid potential confusion related to multiple versions of FSH files in your project. For this same reason, we do not recommend committing your preprocessed FSH to source control.  --snapshot By default, SUSHI only generates the profile differential, allowing the IG Publisher to create the profile snapshot. This is the approach recommended by HL7 FHIR leadership. If authors prefer, the --snapshot (or -s) option can be used to cause SUSHI to generate the snapshot without having to run the IG Publisher.\n--config Typically, SUSHI uses the sushi-config.yaml file to define the configuration options it uses when processing FSH. However, in rare cases, it may be useful to override the values provided in sushi-config.yaml without changing the file itself. For these cases, the --config (or -c) option can be used to specify a configuration property and the override value for it. Currently, this option only allows version, status, and releaselabel to be overridden.\nFor example, specifying sushi build . --config status:active can be used to specify that the status should be “active” for that particular build of SUSHI.\nStatus Messages While SUSHI is running, it will print status messages as it processes your project files. When SUSHI has completed, you should receive a summary like the following:\n╔════════════════════════ SUSHI RESULTS ══════════════════════════╗ ║ ╭───────────────┬──────────────┬──────────────┬───────────────╮ ║ ║ │ Profiles │ Extensions │ Logicals │ Resources │ ║ ║ ├───────────────┼──────────────┼──────────────┼───────────────┤ ║ ║ │ 1 │ 1 │ 1 │ 1 │ ║ ║ ╰───────────────┴──────────────┴──────────────┴───────────────╯ ║ ║ ╭────────────────────┬───────────────────┬────────────────────╮ ║ ║ │ ValueSets │ CodeSystems │ Instances │ ║ ║ ├────────────────────┼───────────────────┼────────────────────┤ ║ ║ │ 1 │ 1 │ 1 │ ║ ║ ╰────────────────────┴───────────────────┴────────────────────╯ ║ ║ ║ ╠═════════════════════════════════════════════════════════════════╣ ║ Fin-tastic job! 0 Errors 0 Warnings ║ ╚═════════════════════════════════════════════════════════════════╝  Note The following message is expected, and should be ignored:(node:46420) Warning: Accessing non-existent property ‘INVALID_ALT_NUMBER’ of module exports inside circular dependency (Use node --trace-warnings ... to show where the warning was created)  Error Messages In the process of developing your IG using FSH, you may encounter SUSHI error messages (written to the command console). Most error messages point to a specific line or lines in a .fsh file. If possible, SUSHI will continue, despite errors, to produce FHIR artifacts, but those artifacts may omit problematic rules. SUSHI should always exit gracefully. If SUSHI crashes, please report the issue using the SUSHI issue tracker.\nHere are some general tips for debugging:\n Parsing (syntax) errors should be fixed first. A single syntax error can balloon into many other errors, so you should always eliminate syntax errors first. Syntax error messages may include extraneous input {x} expecting {y}, mismatched input {x} expecting {y} and no viable alternative at {x}. These messages indicate that the line in question is not a valid FSH statement. The order of keywords matters. The declarations must start with the type of item you are creating (e.g., Profile, Instance, ValueSet). The order of rules usually doesn’t matter, but there are exceptions. Slices and extensions must be created before they are constrained. Rules must contain valid paths. The No element found at path error means that although the overall grammar of the rule may be correct, SUSHI could not find the FHIR element you are referring to in the rule. Make sure there are no spelling errors, the element names in the path are correct, and you are using the path grammar correctly. The community can help. If you are getting an error you can’t resolve, you can ask for help on the #shorthand chat channel.  Structure Definition is Missing Snapshot Error Some non-HL7 FHIR packages are distributed without snapshot elements in their profiles. If your IG uses one of these profiles, SUSHI will report an error like the following:\n Structure Definition http://fhir.de/StructureDefinition/observation-de-vitalsign is missing snapshot. Snapshot is required for import.\n Since SUSHI does not implement its own snapshot generator, you must update the package in your FHIR cache so that its profiles include snapshot elements. Fortunately, the Firely Terminal provides a way to do this.\nFirst, you must install Firely Terminal. Then use Firely Terminal to populate the snapshot elements in the dependency package.\n Run the command: fhir inflate --package \u003cpackagename\u003e, substituting the dependency package ID for \u003cpackagename\u003e.  E.g., fhir inflate --package de.basisprofil.r4   Run SUSHI again. The error about missing snapshots should no longer be displayed.  Tip You can see a list of the available Firely Terminal versions here. Version 3.1.0 or higher is required to use the inflate command. Versions prior to 3.1.0 offer similar functionality via a bake command, but they are no longer recommended.  Firely Terminal Note Inflating a single package, as described above with fhir inflate --package \u003cpackagename\u003e, is a free option in Firely Terminal. Alternately, authors can use fhir install \u003cpackagename\u003e to download, install, and automatically “inflate” the package. Using fhir inflate as a bulk option to inflate the current project and all its dependencies, however, requires a Simplifier license.\nThe Package Management section of the Firely Terminal documentation provides additional details.\n SUSHI Outputs Based on the inputs in FSH files, sushi-config.yaml, and the IG project directory, SUSHI populates the fsh-generated directory. For example, running SUSHI on the my-project project from the Project Structure section would add a fsh-generated folder as shown below:\nmy-project ├── fsh-generated | └── resources | ├── CodeSystem-myCodeSystem.json | ├── Patient-myPatient-example.json | ├── StructureDefinition-myExtension.json | ├── StructureDefinition-myProfile.json | ├── ValueSet-myValueSet.json | └── ImplementationGuide-myIG.json ├── ig.ini ├── input | ├── fsh │ | └── (fsh files) │ ├── ignoreWarnings.txt │ ├── images │ │ ├── myDocument.pdf │ │ ├── myGraphic.png │ │ └── mySpreadsheet.xlsx │ ├── includes │ │ └── menu.xml │ ├── pagecontent │ │ ├── index.md │ │ ├── 2_mySecondPage.md │ │ ├── 3_myThirdPage.md │ │ └── 4_myFourthPage.md ├── package-list.json └── sushi-config.json SUSHI creates only the fsh-generated folder, but some of the files shown above are either processed by SUSHI to create the ImplementationGuide.json file, or can be generated by SUSHI if the author wishes. See the breakdown of files and directories below:\n fsh-generated*: Generated from the definitions in the input/fsh/*.fsh files. ig.ini: Specified by the author and unchanged by SUSHI. input/ignoreWarnings.txt: Specified by the author and unchanged by SUSHI. input/images/*: Specified by the author and unchanged by SUSHI. input/includes/menu.xml: Specified by the author and unchanged by SUSHI, but can alternately be specified via the menu property in sushi-config.yaml. If the menu configuration property is used, the output is generated to fsh-generated/includes/menu.xml. input/pagecontent/*: Specified by the author, numeric prefixes are used by SUSHI in generating the ImplementationGuide-myIG.json file. package-list.json: Specified by the author and unchanged by SUSHI.  Downloading the IG Publisher Scripts To run the IG Publisher, we recommend downloading the _updatePublisher.bat|sh and _genonce.bat|sh scripts provided by the sample-ig project. To get these scripts, download the sample-ig project, unzip it, and copy all of the .bat and .sh files to the directory above the fsh-generated directory (my-project in the example above).\nIf you used sushi init then these scripts were already downloaded and added to your project.\nDownloading the IG Publisher After copying these, change directories in the command prompt to the directory above the fsh-generated directory. At the command prompt, enter:\n  _updatePublisher   ./_updatePublisher.sh This will download the latest version of the HL7 FHIR IG Publisher tool into the /input-cache directory. This step can be skipped if you already have the latest version of the IG Publisher tool in input-cache.\nTip If you are blocked by a firewall, or if for any reason _updatePublisher fails to execute, download the current IG Publisher jar file here. When the file has downloaded, move it into the input-cache directory (which you may need to create as a sibling to the input directory).  Running the IG Publisher Warning If you have never run the IG Publisher, you may need to install Jekyll first. See Installing the IG Publisher for details.  After the IG Publisher has been successfully downloaded, execute the following command to run it:\n  _genonce   ./_genonce.sh This will run the HL7 IG Publisher, which may take several minutes to complete. After the publisher is finished, open the file /output/index.html in a browser to see the resulting IG.\nTip When running SUSHI, the IG Publisher will look for an optional fsh.ini control file in the root directory of the project (the same directory that contains ig.ini). This file should have [FSH] on the first line, and can include a sushi-version property, used to specify which version of SUSHI the IG Publisher should use, and a timeout property, used to set a timeout for SUSHI (in seconds). The default timeout is 60 seconds. An example fsh.ini file is provided below.\n[FSH] sushi-version = 0.16.0 timeout = 120   ","excerpt":" Note This documentation assumes you have a SUSHI-compliant project …","ref":"/docs/sushi/running/","title":"Running SUSHI"},{"body":"GoFSH exposes a fhirToFsh function that can be used to convert FHIR to FSH.\nSyntax fhirToFsh(fhir[, options]) Parameters fhir - An array of FHIR resources, represented either as strings or JSON.\noptions - An object which can have any combindation of the following attributes:\n dependencies - An array of strings used to specify dependencies required for processing the FHIR. Dependencies should use the format \u003cpackageId\u003e@\u003cversion\u003e (example: hl7.fhir.us.core@3.0.1). logLevel - A string that specifies what level of logging to use when processing FHIR. Options are silent, debug, info, warn, and error. style - A string representing how the returned output is styled. The options are:   string - The generated FSH will be returned in one single string. This is the default.\n  map - The generated FSH will be returned as an object. The attributes on the object are:\n aliases - A string containing all Alias definitions. profiles - A Map containing all Profile definitions as values. extensions - A Map containing all Extension definitions as values. codeSystems - A Map containing all CodeSystem definitions as values. valueSets - A Map containing all ValueSet definitions as values. instances - A Map containing all Instance definitions as values. invariants - A Map containing all Invariant definitions as values. mappings - A Map containing all Mapping definitions as values.  For each Map, the keys are the name of the FSH definition. For example, if the definition was:\nProfile: MyPatient Parent: Patient The key would be MyPatient.\n    Return Value A Promise that resolves to an object with the following attributes:\n fsh - The generated FSH, styled according to the style parameter. configuration - An object representing the sushi-config.yaml file that would be generated if GoFSH was running in a command line interface. errors - An array of strings containing any errors detected during processing. warnings - An array of strings containing any warnings detected during processing.  Usage To use fhirToFsh, you must first install gofsh as a dependency of your project:\n npm install gofsh Once gofsh is installed as a dependency of your project, you can import and use this function as shown:\nimport { gofshClient } from 'gofsh'; // Example basic usage gofshClient .fhirToFsh(['{ Your FHIR here }']) .then((results) =\u003e { // handle results  }) .catch((err) =\u003e { // handle thrown errors  }); // Example usage with options gofshClient .fhirToFsh(['{ Your FHIR here }'], { dependencies: [\"hl7.fhir.us.mcode@1.0.0\"], style: \"map\", logLevel: \"silent\", }) .then((results) =\u003e { // handle results  }) .catch((err) =\u003e { // handle thrown errors  }); ","excerpt":"GoFSH exposes a fhirToFsh function that can be used to convert FHIR to …","ref":"/docs/gofsh/api/","title":"API"},{"body":"Running GoFSH GoFSH is executed from the command line. The general form of the GoFSH execution command is as follows:\n gofsh {input-directory} {options} where options include the following (in any order):\n-a, --alias-file \u003cpath\u003e specify an existing FSH file containing aliases to be loaded. -d, --dependency \u003cdependency...\u003e specify dependencies to be loaded using format dependencyId@version (FHIR R4 included by default) -f, --fshing-trip run SUSHI on the output of GoFSH and generate a comparison of the round trip results -h, --help display help for command --indent output FSH with indented rules using context paths -i, --installed-sushi use the locally installed version of SUSHI when generating comparisons with the `-f` option -l, --log-level \u003clevel\u003e specify the level of log messages: error, warn, info (default), debug --meta-profile \u003cmode\u003e specify how meta.profile on Instances should be applied to the InstanceOf keyword: only-one (default), first, none --no-alias output FSH without generating aliases -o, --out \u003cout\u003e the path to the output folder -s, --style \u003cstyle\u003e specify how the output is organized into files: file-per-definition (default), group-by-fsh-type, group-by-profile, single-file -t, --file-type \u003ctype\u003e specify which file types GoFSH should accept as input: json-only (default), xml-only, json-and-xml -u, --useFHIRVersion \u003cversion\u003e indicate which FHIR version to use, if it cannot be determined from inputs (e.g., 4.3.0) -v, --version print the goFSH version While GoFSH is running, it will print status messages as it processes your project files. The following sections give further detail on using certain options.\n--alias-file Use this option to provide GoFSH with an existing alias file. The \u003cpath\u003e can be relative or absolute. Typically, GoFSH will automatically generate an aliases.fsh file based on the content and URLs it encounters during processing. Using the --alias-file (-a) option, the user can specify an existing FSH (.fsh) file that contains desired user-defined aliases.\nExample usage:\ngofsh /path/to/my/ig --alias-file /different/path/to/aliases.fsh --style The style option has four values:\n file-per-definition: Each standalone FSH definition is written to an individual file that is grouped in a folder according to the type of FSH definition it is. Only Aliases are combined into one aliases.fsh file. This is the default choice. group-by-fsh-type: Definitions are written to files based on what type of FSH definition they are (Alias, Profile, Extension, etc.). group-by-profile: Profiles are each written to an individual file. Instances and Invariants that pertain only to a certain Profile are then included in the same file as that Profile. The remaining definitions are grouped as in the group-by-fsh-type option. single-file: All definitions are written to one file.  --fshing-trip Use this flag if you would like to make sure GoFSH isn’t missing anything, by doing a round-trip from FHIR to FSH and back. When this flag is present, after GoFSH runs, SUSHI will run on the output of GoFSH. The output of SUSHI will then be compared to the original input to GoFSH (FHIR is compared to FHIR), and a visualization of differences between the original input and the SUSHI output will be created in \u003coutput-folder\u003e/fshing-trip-comparison.html. If the --installed-sushi flag is set, then this process will use whichever version of SUSHI you have globally installed. Otherwise GoFSH will use its own built-in version of SUSHI (which may not be the latest version available).\n--indent When the --indent option is specified, the output FSH will take advantage of indented rules when applicable. This will also cause CodeSystem definitions to utilize indentation in hierarchical codes, Concept designations, and Concept properties when applicable.\nFor example, without the --indent option, GoFSH will generate this:\n* test[0].id = \"01-ReadPatient-Destination1\" * test[=].name = \"ReadPatient-Destination1\" * test[=].description = \"Read a Patient from the first destination test system using the user defined dynamic variable ${Dest1PatientResourceId}. Perform basic validation.\" * test[=].action[0].operation.type = http://hl7.org/fhir/restful-interaction#read * test[=].action[=].operation.resource = #Patient If the --indent option is used, GoFSH will generate this:\n* test[0] * id = \"01-ReadPatient-Destination1\" * name = \"ReadPatient-Destination1\" * description = \"Read a Patient from the first destination test system using the user defined dynamic variable ${Dest1PatientResourceId}. Perform basic validation.\" * action[0].operation * type = http://hl7.org/fhir/restful-interaction#read * resource = #Patient --meta-profile The --meta-profile option can be used to control how values of meta.profile present in FHIR instances are applied to the InstanceOf keyword in FSH. In FHIR, the value of meta.profile represents a claim that the instance conforms to the given profile(s). One interpretation of meta.profile is that the generated FSH instance is an InstanceOf that profile, which would subsequently result in SUSHI checking to make sure the instance followed the rules of that profile. A potential complication is that meta.profile can have multiple values, but in FSH, an instance can be InstanceOf at most one profile. A different interpretation is that meta.profile is only a hint that adds no concrete information, and thus the FSH instance should ignore meta.profile and should be InstanceOf a native FHIR resource. Both interpretations are permissible in FHIR.\nThe option has the following three values:\n only-one (default): If there is exactly one entry in the meta.profile array of a definition, this value will be used to set InstanceOf. If there is not exactly one entry in the meta.profile array, the resourceType of the definition will be used for InstanceOf, and any contents of the meta.profile array will be specified with ^ rules. first: If there is at least one entry in the meta.profile array, it will be used to set InstanceOf. Additional entries will be specified with ^ rules. none: The meta.profile array will not be used to determine InstanceOf.  GoFSH Inputs GoFSH takes FHIR StructureDefinitions and other FHIR conformance definitions (e.g., ValueSets, CodeSystems) as input. GoFSH requires that these files be JSON. Every JSON file contained in the input directory, or its subdirectories, will be processed by GoFSH into FSH.\nGoFSH does not require any configuration, but if the input FHIR artifacts depend on FHIR artifacts not contained in FHIR R4, these dependencies should be specified with the -d flag. For example, the mcode-cancer-patient profile in the mCODE Implementation Guide is derived from the us-core-patient profile in the US Core Implementation Guide. If you wanted to use GoFSH to convert the mcode-cancer-patient profile to FSH, you should specify US Core as a dependency:\n gofsh ./mcode-definitions -d hl7.fhir.us.core@3.1.0  Info GoFSH can still generate FSH when dependencies are omitted, but the resulting FSH will be incomplete.  GoFSH Outputs GoFSH populates an output directory, called gofsh by default. This directory will contain an input/fsh directory. The input/fsh directory will contain several .fsh files organized according to the file-per-definition style described above. Additionally, the input/fsh directory will contain an index.txt file which describes which file contains each definition. The gofsh directory will also contain a sushi-config.yaml file. If the input to GoFSH includes an ImplementationGuide resource, it is used to generate the configuration. Otherwise the configuration is generated by inferring values from the input, or by using sensible defaults if no values can be inferred. These definitions and configuration are ready to use with SUSHI, all you have to do is run SUSHI.\nGoFSH Best Practices The following are a few tips to get the best results from GoFSH. Following these suggestions will help eliminate errors from GoFSH and will produce more accurate FSH.\n  For best results, run GoFSH against FHIR definitions that are complete (i.e., have snapshots) and have been validated. The best sources are:\n a package downloaded from an IG or FHIR registry (after unzipping it), a package in your local FHIR cache, or an IG project’s output folder after it has been built by the IG Publisher.    If running GoFSH against a fully built package is not possible, run GoFSH against the project’s input folder, rather than against the entire IG source folder.\n  Be sure to use the proper flag to indicate whether GoFSH should process JSON or XML files in the target directory (or both). When in doubt, use the json-only mode, which is the default.\n  When possible, avoid running GoFSH on folders that contain:\n duplicate files (i.e. definitions that are present in both input and output), incomplete files (i.e. definitions without a snapshot), or extra files that are not intended to be translated to FSH (e.g, menu.xml, files in the input-cache directory).    Be aware that IGs with errors in the FHIR Publisher’s QA report may result in FSH that does not compile cleanly.\n  SUSHI may be more strict than the IG Publisher. As a result, issues that were not flagged by the IG Publisher may be flagged by SUSHI, and occasionally, technically valid constructs may result in inefficient or confusing FSH.\n  Use the --fishing-trip option to run SUSHI on the output of GoFSH and compare the round trip results.\n  Always review the results of GoFSH to ensure that they are correct and complete.\n  ","excerpt":"Running GoFSH GoFSH is executed from the command line. The general …","ref":"/docs/gofsh/running/","title":"Running GoFSH"},{"body":"Specifying Additional Resource Paths Sometimes authors may wish to put predefined resources in folders other than the normally supported input sub-folders. To support this, SUSHI now recognizes the ImplementationGuide parameter path-resource. Authors can include this parameter in sushi-config.yaml to specify relative paths to additional folders that contain predefined resources. For example, the following can now be used in sushi-config.yaml to include resources from the sub-folder predefined-resources:\nparameters:path-resource:- input/predefined-resourcesNote that the value of path-resource is an array (or sequence) formatted in the standard YAML style.\nFor SUSHI users who manage their own ImplementationGuide resource (i.e. FSHOnly IGs), SUSHI will use the parameter from the ImplementationGuide resource:\n\"parameter\": [ { \"code\": \"path-resource\", \"value\": \"input/predefined-resource\" } ] Support for contentReference Elements Content references allow ElementDefinitions to refer to be defined in terms of other elements. A typical application of a content reference is to prevent infinite regress in elements such as Questionnaire.item.item, whose the definition refers back to Questionnaire.item via a content reference.\nContent references are supported in AddElementRules by way of the contentReference keyword. This feature applies to Logical Models and custom Resources. To define an element of type contentReference, include contentReference \u003curl-to-referenced-element\u003e in the AddElementRule where the type would typically go. For example, the following AddElementRule will create an element section.section that is a contentReference to the element found at http://example.org/StructureDefinition/Report#Report.section.\n* section.section 0..1 contentReference http://example.org/StructureDefinition/Report#Report.section \"A sub-section\" Inferred Choice Path When assigning values to choice elements (e.g., value[x]) on an Instance, type-specific elements (e.g., valueBoolean) should always be used in assignment rules. However, if the choice element has been constrained to a single type, SUSHI will infer the correct type-specific element.\nFor example, SUSHI will infer the last line is to be interpreted as * valueBoolean = true as the Instance is exported. Authors are encouraged to not depend on this behavior, and use type-specific elements in instances.\nProfile: BooleanObservation Parent: Observation * value[x] only boolean Instance: MyObservation InstanceOf: BooleanObservation * status = #final * code = http://example#somecode * value[x] = true Referencing the Canonical URL of the ImplementationGuide There may be cases where an author needs to refer to the canonical URL of the ImplementationGuide resource they are creating. SUSHI now supports using the Canonical keyword with the IG’s id, packageId, or name that is specified in sushi-config.yaml. For example, when creating a CapabilityStatement, the following Assignment Rule can be added:\n* implementationGuide = Canonical(my-package-id) Extensions for Representing Elements From Other Versions of FHIR The FHIR specification defines behavior for a feature they refer to as extensions for converting between versions (also known as “implied extensions”). This feature allows authors to represent specific elements from past and future versions of FHIR using a specific extension URL format (as described in the spec linked above). These extensions are not available in any physical package, but rather, are understood and processed conceptually.\nTo use this feature in SUSHI, authors must specify a dependency on a package using an id and version of the form hl7.fhir.extensions.\u003cextension-version\u003e: \u003cpackage-version\u003e, where valid extension-versions are r2, r3, r4, and r5. As an example, if an author wanted to represent the Patient.animal.species element as defined in STU3, the dependencies should be specified as:\ndependencies:hl7.fhir.extensions.r3:4.0.1An author can then reference the extension using a URL following the format defined in the FHIR specification linked above. For example, the extension referring to the R3 Patient.animal.species element would be: http://hl7.org/fhir/3.0/StructureDefinition/extension-Patient.animal.species.\nSee the following documentation for additional details:\n Dependencies from the FSH School SUSHI documentation Extensions for Converting Between Versions from the current FHIR specification  Extension for Profiling BackboneElements The profile-element extension can be used to profile a BackboneElement by pointing at another BackboneElement defined elsewhere. This is typically used to indicate that constraints on the target of a contentReference should be applied to all the references as well. For example, the following snippet indicates that all recursive references to Questionnaire.item (e.g., Questionnaire.item.item) should conform to the same constraints as the original Questionnaire.item in this profile:\nProfile: MyQuestionnaire Parent: Questionnaire * item ^type.profile = \"http://example.org/StructureDefinition/MyQuestionnaire\" * item ^type.profile.extension.url = \"http://hl7.org/fhir/StructureDefinition/elementdefinition-profile-element\" * item ^type.profile.extension.valueString = \"Questionnaire.item\" // ... See the following documentation for additional details:\n Extension: profile-element from the FHIR specification Clarification on contentReference discussion on Zulip  Instances of Logical Models The IG Publisher supports including instances of logical models as binary resources. This feature was announced and discussed in a Logical Model Examples thread on chat.fhir.org.\nAuthors can use Instance: to create instances of logical models and instances of logical model profiles in the same way as all other FSH instances. These instances are exported using standard JSON serialization and automatically receive id and meta.profile values when the logical model and SUSHI configuration support those elements. These instances have filenames starting with Binary- and will be auto-encoded as part of the publishing process.\nAlternatively, authors can provide their own instances of logical models without defining them in FSH. The basic steps an author needs to take in order to manually include logical model examples in a SUSHI project are:\n Add the example to the input/resources or input/examples folder  The file name of the example should be Binary-{id}.json or Binary-{id}.xml (substituting {id} for the real id)   Add an entry for the example in the sushi-config.yaml resources property  Specify a name Specify exampleCanonical pointing to the canonical of your logical model Add an extension w/ the proper resource format (application/fhir+json or application/xml)    For example, given the following simple logical model definition in an IG w/ IG canonical root http://example.org:\nLogical: MyLM Id: MyLM Title: \"My LM\" Description: \"This is mine\" * id 1..1 SU id \"Identifier for the logical model\" * important 1..1 SU boolean \"Is this logical model important\" Create the file input/examples/Binary-my-logical-example.json:\n{ \"resourceType\": \"http://example.org/StructureDefinition/MyLM\", \"id\": \"my-logical-example\", \"important\": true } And add the following in your sushi-config.yaml:\nresources:Binary/my-logical-example:extension:- url:http://hl7.org/fhir/tools/StructureDefinition/implementationguide-resource-formatvalueCode:application/fhir+jsonname:ExampleofLMexampleCanonical:http://example.org/StructureDefinition/MyLMBoth approaches will result in your logical model example being listed and displayed as a proper example of the logical model.\nIf the logical model does not have resourceType or id, the same steps as above can be used with a few small adjustments:\n In step 1, the file name of the example can be any valid file name (e.g. hook-example.json) In step 2, the key in the resources list should be Binary/{filename}, where {filename} matches the the file name of the example without the file extension (e.g. Binary/hook-example)  Manual Slice Ordering Authors can exercise full manual control over the ordering of slice elements within Instances. Previous versions of SUSHI allowed for partial control of slice element ordering, but some ordering was determined by SUSHI’s implementation and could not be affected by an author. In the current version of SUSHI (v3.0.0 or later), authors can configure their FSH projects to manually control slice ordering. When using manual slice ordering, authors should use soft indexing and avoid using hard numeric indices.\nManual slice ordering follows the following rules:\n slices appear on an Instance in the order of FSH rules any required slices (1..*) that are not referenced in a FSH rule on the Instance appear after all referenced slices in the order in which they are defined on the Instance’s StructureDefinition (the instance’s InstanceOf) a rule that references a sliced element should reference it using the slice name to reference multiple items in a slice, use hard or soft indices after the slice name (e.g., component[myslice][0]) when rule paths use only a soft index (instead of a slice name), the resolved numeric index will take into account named slices that have already been referenced by previous rule paths. This should only be used to add items that do not belong to a defined slice.  Note: when manual slice ordering is enabled, it is not possible to refer to an element with a slice name by soft numeric index only. If hard numeric indices are used (not recommended), they may still directly access previously referenced named slices. This may lead to undesired output.    To use this ordering, add the following to sushi-config.yaml:\ninstanceOptions:manualSliceOrdering:trueExamples Profile: ExampleBPObservation Parent: Observation // slicing rules for component omitted for brevity * component contains systolicBP 1..1 MS and diastolicBP 1..1 MS When using this profile without manual slice ordering, the systolicBP slice will always be the first entry in the component element, and the diastolicBP slice will always be the second entry in the component element. So, the following two instances would have the same component elements:\nInstance: ExampleByName InstanceOf: ExampleBPObservation // some required elements omitted for brevity * component[systolicBP].valueQuantity = 108 'mm[Hg]' * component[diastolicBP].valueQuantity = 45 'mm[Hg]' Instance: ExampleByNumber InstanceOf: ExampleBPObservation // some required elements omitted for brevity * component[0].valueQuantity = 108 'mm[Hg]' * component[1].valueQuantity = 45 'mm[Hg]' When manual slice ordering is enabled, rules that set values on the systolicBP or diastolicBP slices must use the slice name. With this option enabled, the ExampleByName instance would produce the same entries in component, but the ExampleByNumber instance would contain four entries in the component list: two entries that are not part of a named slice, followed by the systolicBP slice, and finally the diastolicBP slice.\nWhen manual slice ordering is enabled, if any required slices with required assigned values are not present in an instance’s list of rules, they will be added in the order in which they are defined. If you want these slices to appear in a different order on the instance without adding any new information to the slices, add rules on the instance that reassign the existing values:\nAlias: $ObservationCategoryCodes = http://terminology.hl7.org/CodeSystem/observation-category Profile: ExampleObservation Parent: Observation // slicing rules for category omitted for brevity * category contains CategoryA 1..1 and CategoryB 1..1 * category[CategoryA] = $ObservationCategoryCodes#vital-signs * category[CategoryB] = $ObservationCategoryCodes#survey Instance: ReorderedExample InstanceOf: ExampleObservation // some required elements omitted for brevity * category[CategoryB] = $ObservationCategoryCodes#survey * category[CategoryA] = $ObservationCategoryCodes#vital-signs This instance’s category element will have the survey code as the first entry and the vital-signs code as the second entry.\nSoft index resolution will account for named slices that have been referenced in previous rules:\nInstance: SoftIndexExample InstanceOf: ExampleObservation // some required elements omitted for brevity * category[+] = $ObservationCategoryCodes#laboratory // this + will resolve to index 0 * category[CategoryB] = $ObservationCategoryCodes#survey * category[+] = $ObservationCategoryCodes#exam // this + will resolve to index 2, since the CategoryB slice occupies index 1 * category[CategoryA] = $ObservationCategoryCodes#vital-signs This instance’s category element will have four entries in the order specified: laboratory, survey, exam, vital-signs.\nLink References SUSHI creates the fsh-generated/includes/fsh-link-references.md file to make it easier to create links to resource definitions in other markdown pages. This file’s contents are a list of markdown link definitions, with one link for each resource in your ImplementationGuide.json file. This will include resources defined in FSH, the resources configuration property, and predefined resources. For example:\n[MyPatient]: StructureDefinition-MyPatient.html [MyExtension]: StructureDefinition-MyExtension.html The rules for determining what the link text will be for a given resource are as follows:\n For resources defined in FSH:  Non-instance resources use the name of the resource. Instances use the id of the resource.   For predefined resources:  Resources in the input/examples folder use the id of the resource. Resources in other sub-folders of input attempt to use the name of the resource if this is a string value, and otherwise use the id of the resource.   For resources that are manually configured in sushi-config.yaml:  The name of the resource is used, if available. Otherwise, the id of the resource is used.    To use these generated links, include fsh-generated-links.md in your custom markdown pages. This can be done by including the following line at the bottom of your custom markdown page:\n{% include fsh-link-references.md %} Then, you can create links by including the resource’s link text within square brackets. For example, if you had a Profile named MyPatient, your custom markdown file could look like this:\n## Patients This IG provides [MyPatient] for patient information. {% include fsh-link-references.md %} Choosing a SNOMED CT edition To specify a certain edition of SNOMED CT - for example to ensure terminology validation works correctly - do the following:\n Add or modify the parameters section in your sushi-config.yaml to specify a path-expansion-params parameter.  parameters:path-expansion-params:Parameters-expansion.jsonCreate an input/fsh/expansion.fsh file and define an instance of Parameters with the id expansion. Within the Parameters instance, specify a system-version parameter. For example, if you’d like to use the US edition of SNOMED, add this definition:  Instance: expansion InstanceOf: Parameters Description: \"SNOMED CT expansion parameter\" Usage: #definition * parameter[+].name = \"system-version\" * parameter[=].valueCanonical = \"http://snomed.info/sct|http://snomed.info/sct/731000124108\" If you’d like to use another language, such as Swedish, choose this:\nInstance: expansion InstanceOf: Parameters Description: \"SNOMED CT Swedish expansion parameter\" Usage: #definition * parameter[+].name = \"displayLanguage\" * parameter[=].valueCode = urn:ietf:bcp:47#se * parameter[+].name = \"system-version\" * parameter[=].valueCanonical = \"http://snomed.info/sct|http://snomed.info/sct/45991000052106\" Note: The system-version and displayLanguage parameters correspond to the parameters of the same name in FHIR’s $expand operation.\n","excerpt":"Specifying Additional Resource Paths Sometimes authors may wish to put …","ref":"/docs/sushi/tips/","title":"Tips and Tricks"},{"body":"Because FHIR Shorthand files are pure text, authors can use any text editor to create FSH content. However, if you choose the popular (and free) Visual Studio Code (VS Code) editor, there is a FSH-specific extension that can greatly enhance your productivity through syntax highlighting, helping you navigate, and even running SUSHI and navigating directly to errors.\nThe VS Code FSH extension (formally, MITRE-Health.vscode-language-fsh) offers the following features:\n Syntax highlighting. Colorizing FSH text allows easier reading and writing of FHIR Shorthand. Autocomplete. This feature makes contextually appropriate suggestions after when specifying a nested path, the Parent keyword, and when writing obeys rules. Tasks. The extension allows you to run SUSHI and check your work inside the VS Code environment. SUSHI’s log messages go to the integrated Terminal tab, and errors go to VS Code’s Problems tab. Selecting an error or warning will navigate directly to the line or area of code responsible for the error or warning. Go to Definition. This feature allows quick navigation to the definition of an item, anywhere the name of the item is used. If it is a native FHIR item, the link to the documentation page is offered. Snippets. This feature automatically adds relevant keywords and placeholders so you can easily enter all of the recommended metadata for a FSH definition.  Here is an example of syntax highlighting:\nInstallation To install VS Code on macOS, Windows, or Linux, follow the instructions here.\nTo install the FHIR Shorthand extension, run VS Code, and navigate to View \u003e Extensions or select the icon on the far left that looks like four little squares. Then search for “FHIR Shorthand” and make sure you pick the extension with the fish icon, “FHIR Shorthand (FSH) Language Support by MITRE”. Click on the associated gear icon and then “install”.\nFull Documentation Full documentation for the FHIR Shorthand language extension for VS Code can be found here. Once installed in VS Code, the documentation can be accessed by clicking on the installed FHIR Shorthand extension (look for the fish icon on the Extensions pane on the left navigation bar).\n","excerpt":"Because FHIR Shorthand files are pure text, authors can use any text …","ref":"/docs/vscode/","title":"Visual Studio Code Extension"},{"body":"This tutorial will walk you through an example of using GoFSH to turn FHIR artifacts into FSH definitions. This tutorial assumes you have already installed GoFSH.\nStep 1: Download Sample FHIR Artifacts To start with some example FHIR artifacts,  download the GoFSH Tutorial and unzip it into a directory of your choice.\nAfter the file is unzipped, you should see two FHIR artifacts:\n StructureDefinition-mcode-genetic-specimen.json StructureDefinition-mcode-laterality.json  Step 2: Run GoFSH Now that you have GoFSH installed and sample FHIR artifacts, open up a command window, and navigate to the directory containing the artifacts you downloaded. Run GoFSH on those files by executing:\n gofsh .  Note The dot (.) represents “this directory,” the location of the files. You can also specify the location explicitly by replacing the dot with a directory path.  Running GoFSH will create a gofsh directory, and populate it with input/fsh, a directory containing several files which define the original input files. Within input/fsh, there will be two subdirectories, profiles and extensions. If you open up profiles/GeneticSpecimen.fsh, you should see a FSH definition for a Profile called “GeneticSpecimen”, and if you open up extensions/Laterality.fsh, you should see an Extension called “Laterality”.\nStep 3: Run SUSHI (Optional) Now that you have generated FSH definitions, you can run SUSHI on those definitions to recreate your original input to GoFSH. First, ensure you have SUSHI installed. Then, navigate the command line to the gofsh/ directory, and run:\n sushi build . This command will run SUSHI on the contents of input/fsh, and generate the output of that FSH into a directory called fsh-generated/resources. You can then compare the output from running GoFSH and then SUSHI to the original StructureDefinition-mcode-genetic-specimen.json and StructureDefinition-mcode-laterality.json files.\nAlternatively, you can automatically run SUSHI on the output of GoFSH using the -f option. The following command:\n gofsh . -f will run SUSHI on the output of GoFSH, and generate a comparison file in gofsh/fshing-trip-comparison.html which displays differences between the original input, and the output of SUSHI.\n","excerpt":"This tutorial will walk you through an example of using GoFSH to turn …","ref":"/docs/gofsh/tutorial/","title":"GoFSH Tutorial"},{"body":"FHIR Shorthand (FSH) is a specially-designed language for defining the content of FHIR Implementation Guides (IGs). It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and IGs. FSH is compiled from text files to FHIR artifacts using SUSHI. To get started using FSH, you need to install and run SUSHI using the steps below.\nTip If you find this helpful, you may also want to look at our self-service FSH Seminar course, which includes a more extensive walkthrough of using SUSHI and FSH.  Step 1: Review Introduction If you haven’t done so already, please read or review the Introduction documentation to gain an understanding of the conventions used in this tutorial and the resources available to you.\nStep 2: Install Node.js and Sushi If you have not already installed SUSHI, follow the SUSHI Installation instructions.\nStep 3: Download Sample FSH Project To start with some working examples of FSH files and a skeleton FSH project,  download the FSH Tutorial Starter and unzip it into a directory of your choice.\nAfter the file is unzipped, you should see two subdirectories:\n FishExample FishExampleComplete  Change the working directory to FishExample. There is a sushi-config.yaml file, and two FSH files within the /input/fsh subdirectory:\n FishPatient.fsh Veterinarian.fsh  In addition, there are several files for building the IG.\nStep 4: Run SUSHI Now that you have SUSHI installed and a minimal FSH project, open up a command window, and navigate to the FishExample directory. Run SUSHI on those FSH files by executing:\n sushi build .  Note The dot (.) represents “this directory,” the location of the FSH files. You can also specify the location explicitly by replacing the dot with a directory path.  Running SUSHI will create a FishExample/fsh-generated directory, and populate it with the files needed to create the IG using the HL7 FHIR IG Publisher tool.\nWhile running SUSHI, there will be a series of informational messages. When SUSHI completes, you should see a summary output similar this:\n╔════════════════════════ SUSHI RESULTS ══════════════════════════╗ ║ ╭───────────────┬──────────────┬──────────────┬───────────────╮ ║ ║ │ Profiles │ Extensions │ Logicals │ Resources │ ║ ║ ├───────────────┼──────────────┼──────────────┼───────────────┤ ║ ║ │ 2 │ 0 │ 0 │ 0 │ ║ ║ ╰───────────────┴──────────────┴──────────────┴───────────────╯ ║ ║ ╭────────────────────┬───────────────────┬────────────────────╮ ║ ║ │ ValueSets │ CodeSystems │ Instances │ ║ ║ ├────────────────────┼───────────────────┼────────────────────┤ ║ ║ │ 0 │ 0 │ 0 │ ║ ║ ╰────────────────────┴───────────────────┴────────────────────╯ ║ ║ ║ ╠═════════════════════════════════════════════════════════════════╣ ║ Fin-tastic job! 0 Errors 0 Warnings ║ ╚═════════════════════════════════════════════════════════════════╝ The files generated by SUSHI are located in the FishExample/fsh-generated directory. Check that the FishExample/fsh-generated/resources subdirectory contains two generated StructureDefinitions and a generated ImplementationGuide.\nStep 5: Generate the Sample IG At the command prompt, enter:\n  _updatePublisher   ./_updatePublisher.sh This will download the latest version of the HL7 FHIR IG Publisher tool into ./input-cache. This step can be skipped if you already have run the command recently, and have the latest version of the IG Publisher tool.\nTip If you are blocked by a firewall, or if for any reason _updatePublisher fails to execute, download the current IG Publisher jar file here. When the file has downloaded, move it into the directory /FishExample/input-cache (creating the directory if necessary).  Warning Before proceeding to the next command: If you have never run the IG Publisher, you may need to install Jekyll first. See Installing the IG Publisher for details.  Now run:\n  _genonce   ./_genonce.sh This will run the HL7 FHIR IG generator, which may take several minutes to complete.\nAfter the publisher is finished, open the file /FishExample/output/index.html to see the resulting IG.\nIf you click on the Artifacts Summary item in the menu, you will see that the IG contains two profiles, FishPatient and Veterinarian. If you look at each of them, you will notice that they have minimal differentials. The only way in which they differ from their base resource is that they require at least one name.\nStep 6: Setting Cardinalities in a Profile It is not widely known, but FHIR is designed to be used for veterinary medicine as well as human. For a non-human patient, we need to record the species. The Patients in this Tutorial are going to be various species of fish 🐟.\nSince fish don’t get legally married (although some species do pair bond) and they don’t communicate in a human language, the first thing we’ll do in the FishPatient profile is eliminate these elements. To do this, open the file FishPatient.fsh in your favorite plain-text editor, and add the following rules after the last non-blank line in the file:\n* maritalStatus 0..0 * communication 0..0 Note that rules start with *. FSH expresses cardinality as, {min}..{max}, the same as FHIR.\nStep 7: Create a Species Extension for FishPatient To specify the species of our aquatic patients, we’ll need an extension.\nWe have a choice of whether to make the extension inline or standalone. Inline extensions do not result in a separate StructureDefinition, and cannot be reused in other profiles. Standalone extensions are the opposite: they have independent StructureDefinitions, and can be reused. For this example, let’s make a standalone extension.\nExtensions are created using the contains keyword. To add a standalone species extension, add the following rule after the cardinality rules:\n* extension contains FishSpecies named species 0..1 This rule states that the extension array of the Patient resource will incorporate the FishSpecies extension with the local name species.\nTo define the FishSpecies extension, add the following lines to the end of the FishPatient.fsh file:\nExtension: FishSpecies Id: fish-species Title: \"Fish Species\" Description: \"The species of the fish.\"  Tip FSH ignores extra whitespace, so authors can choose to use whitespace for improved visual alignment, as in the extension definition above.  Run SUSHI again (sushi build .). The count of Extensions should now be 1.\nStep 8: Define a Value Set for Fish Species The FishSpecies extension doesn’t quite do its job yet, because we haven’t specified what type of values it might accept. To add this information, enter these lines following the description of FishSpecies:\n* value[x] only CodeableConcept * valueCodeableConcept from FishSpeciesValueSet (extensible) The first rule restricts the value[x] (a built-in element of every FHIR extension) to a CodeableConcept using the only keyword. The second binds it to a value set (yet to be defined) using the from keyword. The binding strength will be extensible, meaning the codes in the FishSpeciesValueSet must be used except when the value set is missing a specific fish species.\nTo define FishSpeciesValueSet, add the following lines to the same file:\nValueSet: FishSpeciesValueSet Title: \"Fish Species Value Set\" Id: fish-species-value-set Description: \"Codes describing various species of fish, taken from SNOMED-CT.\" * codes from system http://snomed.info/sct where concept is-a SCT#90580008 \"Fish (organism)\"  Info The rule in the value set definition above selects all codes from SNOMED-CT that are children of the concept “Fish (organism)”.  Run SUSHI again. The count of ValueSets should now be 1. Try generating the IG by running _genonce again. Open the file /FishExample/output/index.html to see the resulting IG.\n Do you see where the FishPatient profile is in the IG? Does the differential reflect your changes? How does FHIR render the value set you defined?  Step 9: Define an Alias An Alias is a way to define a shorthand for a URL or OID. For example, in the value set definition above, we could have defined an Alias to make referencing the http://snomed.info/sct URL easier, as shown below. Aliases are conventionally defined at the top of the file.\nAdd this line at the top of the FishPatient.fsh file:\nAlias: SCT = http://snomed.info/sct and then replace the last line in the FishSpeciesValueSet with:\n* codes from system SCT where concept is-a #90580008 \"Fish (organism)\"  Tip Using aliases has no effect on the IG; it simply makes the FSH code a bit neater.  Step 10: Create an Instance of FishPatient Every IG should provide examples of its profiles. Let’s do that by introducing an example FishPatient named Shorty. Create this example instance using the Instance keyword, with InstanceOf set to FishPatient and Usage set to Example.\nInclude the following information about Shorty in the instance:\n His given (first) name is “Shorty” and his family (last) name is “Koi-Fish”. Shorty is a Koi fish (Cyprinus rubrofuscus), represented as SNOMED-CT code 47978005 “Carpiodes cyprinus (organism)”.  If you need help with this, you can reference the Defining Instances section of the specification. If you still need help, you can peek at the FSH files in the FishExampleComplete directory.\nRun SUSHI again, and re-generate the IG.\n Did it compile without errors? What does the IG look like now?  Step 11: Extend the Veterinarian Profile Now, add constraints and/or extensions to the Veterinarian profile:\n  Add qualifications consistent with a Veterinary practice. Qualifications are taken from code system http://nucc.org/provider-taxonomy, and the code is 174M00000X, for “Veterinarian”.\n  In addition, slice the identifier array, making a license number required. The code system is http://terminology.hl7.org/CodeSystem/v2-0203 and the code is LN, for “License number”.\n  If you need help with this, you can refer to the assignment rules and slicing rules sections of the specification. If you still need help, you can peek at the FSH files in the FishExampleComplete directory.\nRun SUSHI again, and re-generate the IG.\n Did it compile without errors? What does the IG look like now?  Congratulations! You’ve completed the FSH tutorial. It might be time to feast on some sushi!\n","excerpt":"FHIR Shorthand (FSH) is a specially-designed language for defining the …","ref":"/docs/sushi/tutorial/","title":"SUSHI Tutorial"},{"body":"SUSHI exposes a fshToFhir function that can be used to convert FSH strings to FHIR JSON.\nSyntax fshToFhir(fshString[, options]) Parameters fshString - A string containing FHIR Shorthand definitions.\noptions - An object which can have any combination of the following attributes:\n canonical - A string used to specify the canonical URL. version - A string used to specify the version. fhirVersion - A string used to specify the version of FHIR to use. Note that SUSHI only supports FHIR R4 and R5. dependencies - An array of objects used to specify dependencies required for processing the FSH. Each object should have a packageId and version, and optionally a uri. logLevel - A string that specifies what level of logging to use when processing FSH. Options are silent, debug, info, warn, and error. snapshot - (EXPERIMENTAL) A boolean that specifies whether to generate the snapshot data element in Structure Definition output (default: false)  Warning The snapshot option, when set to true, triggers the generation of StructureDefinition.snapshot data elements. Use of this option should be considered EXPERIMENTAL! The StructureDefinition.snapshot data elements generated by SUSHI are likely not perfect and differ from the snapshots that the IG Publisher and/or Simplifier would create. If you plan to publish these resources, it would be better to use one of those other tools to generate the snapshots.  See the configuration documentation for more information on canonical, version, fhirVersion, and dependencies. These properties correspond to the properties of the same name that are used in sushi-config.yaml.\nReturn Value A Promise that resolves to an object with the following attributes:\n fhir - An array of FHIR definitions generated from the input FSH. errors - An array of objects containing any errors detected during processing. Each object has a message with the error message and optionally has input and location properties with additional information. warnings - An array of objects containing any warnings detected during processing. Each object has a message with the warning message and optionally has input and location properties with additional information.  Usage To use fshToFhir, you must first install fsh-sushi as a dependency of your project:\n npm install fsh-sushi Once fsh-sushi is installed as a dependency of your project, you can import and use this function as shown:\nimport { sushiClient } from 'fsh-sushi'; // Example basic usage sushiClient .fshToFhir('Your FSH here') .then((results) =\u003e { // handle results  }) .catch((err) =\u003e { // handle thrown errors  }); // Example usage with options sushiClient .fshToFhir('Your FSH here', { canonical: \"http://example.com\", version: \"1.2.3\", fhirVersion: \"4.0.1\", dependencies: [{ packageId: \"hl7.fhir.us.core\", version: \"3.1.0\" }], logLevel: \"error\", }) .then((results) =\u003e { // handle results  }) .catch((err) =\u003e { // handle thrown errors  }); ","excerpt":"SUSHI exposes a fshToFhir function that can be used to convert FSH …","ref":"/docs/sushi/api/","title":"API"},{"body":"","excerpt":"","ref":"/about/","title":"About"},{"body":"","excerpt":"","ref":"/community/","title":"Community"},{"body":"This is the documentation for SUSHI and GoFSH. (This is not the FSH documentation; see the following section for more details.)\nWhat is FSH? FSH (FHIR Shorthand) is a specially-designed language for defining the content of HL7 FHIR Implementation Guides (IGs). It is designed to be simple and compact, and along with SUSHI can be used to produce FHIR profiles, extensions, and IGs.\nIf you are new to FHIR and FSH, or want more information, please see below.\nWhat is SUSHI? SUSHI (SUSHI Unshortens ShortHand Inputs) is a FSH compiler. SUSHI converts FSH language to FHIR artifacts. SUSHI can run in stand-alone mode or as part of the HL7 IG Publisher.\n→ SUSHI documentation\nWhat is GoFSH? GoFSH is a converter that takes FHIR artifacts (e.g., profiles, extensions, value sets, instances) and produces equivalent FSH. GoFSH is essentially the opposite of SUSHI. GoFSH helps you transition to FSH if you have an existing Implementation Guide produced by other methods.\n→ GoFSH documentation\n FSH School Conventions The following style conventions are used throughout the FSH School content:\n   Style Explanation Example     Code Code fragments, such as commands, FSH statements, and syntax expressions * status = #open   {curly braces} An item to be substituted in a syntax expression {display string}   \u003cdatatype\u003e An element or path to an element with the given data type, to be substituted in the syntax expression \u003cCodeableConcept\u003e   italics An optional item in a syntax expression ”{string}“   ellipsis (…) Indicates a pattern that can be repeated {flag1} {flag2} {flag3} …   bold A directory path or file name example-1.fsh    In addition, the following symbols are used in documented commands:\n   Symbol Explanation      Indicates information or command specific to OS X. Commands can be run within the Terminal application.    Indicates information or command specific to Windows. A command window can be launched by typing cmd at the Search Windows tool.    Represents command prompt (may vary depending on platform)     Getting started with FHIR and FSH FHIR and FHIR Profiling Most FSH School resources assume a basic understanding of FHIR and FHIR profiling. A good way to get started is to go through our self-service FSH Seminar course: Getting Started with New Tools to Create Swimmingly Slick Implementation Guides. This covers how to read FHIR IGs and how to use FSH for FHIR Profiling.\nReaders who are new to FHIR should also view the FHIR Specification (also linked in the right-hand sidebar). You may find the following more specific links helpful as well:\n Profiling: Provides information and guidance on profiling topics such as constraining and slicing. Extensibility: Provides information about using and defining extensions. Resources: Lists all FHIR resources. Useful for referencing available elements as you write profiles. DataTypes: Lists all FHIR datatypes. Useful for understanding types declared in resource elements. StructureDefinition: Documents StructureDefinition (basis for resources, profiles, and extensions). Useful for authoring top-level caret rules. ElementDefinition: Documents ElementDefinition (basis for elements in resources, profile, and extensions). Useful for authoring path-specific caret rules.  Additionally, these other resources may be of interest:\n Guidance for FHIR IG Creation: (Work in Progress) Documents the new template-based publishing framework. IG Publisher: Documents how to use and configure the HL7 IG Publisher.  FSH We recommend new FSH authors start with the overview and review the language reference that are part of official FSH Specification when additional details are needed.\nAdditionally, all FSH authors are strongly recommended to go on the Deep Dive with FSH (part of our self-service FSH Seminar course).\n","excerpt":"This is the documentation for SUSHI and GoFSH. (This is not the FSH …","ref":"/docs/","title":"Documentation"},{"body":"  Downloads Various presentations and software you can download.\nFHIR Shorthand Quick Reference Sheet A “cheat sheet” with the entire FSH Grammar at a glance\nThe Full FHIR Shorthand Specification A zip file containing the entire formal specification\nSUSHI Software  Open a command window At the prompt, type npm install -g fsh-sushi  For full instructions and prerequisites, see SUSHI Installation\nGoFSH Software  Open a command window At the prompt, type npm install -g gofsh  For full instructions and prerequisites, see GoFSH Installation\nPresentations  Introduction to FHIR Shorthand, from FHIR DevDays, November 2020  Slides here   Let’s Build - Profiling with FHIR Shorthand, from FHIR DevDays, November 2020  Slides here   Advanced FHIR Shorthand and Tools, from FHIR DevDays, June 2021  Slides here   Create an Implementation Guide with FHIR Shorthand, from FHIR DevDays, June 2021  Slides here   Let’s Build - Create an Implementation Guide, from FHIR DevDays, June 2021  Slides here       ","excerpt":"  Downloads Various presentations and software you can download.\nFHIR …","ref":"/downloads/","title":"Downloads"},{"body":"  #td-cover-block-0 { background-image: url(/featured_background_hu4a44ec3aa90c45d7afea30eeeb2dfc6d_537513_960x540_fill_catmullrom_top_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured_background_hu4a44ec3aa90c45d7afea30eeeb2dfc6d_537513_1920x1080_fill_catmullrom_top_2.png); } }  Welcome to FSH School Quick Start   Read the Docs   Play With FSH   Online Course   Who Else Is FSHing?   The place to learn and try FHIR Shorthand\n\n        FHIR Shorthand (FSH) is a domain-specific language for defining the contents of FHIR Resources and Implementation Guides. Explore FSH School to get the knowledge you need to get started using FSH.       Declarative FSH allows you to define FHIR profiles in a simple, declarative language. No more large JSON files or spreadsheets, just human-readable text files which compile to the FHIR artifacts you need.\n   Fast and Agile FSH is amazingly compact, fun to write, and painless to modify when you need to make changes. Take a look at the official FSH specification for more information about how FSH can be used to profile FHIR.\n   Source control ready Unlike other tools for profiling FHIR, FSH works seamlessly with source control tools like GitHub. Maintain a history of changes, track contributions, and maintain agility by using FSH with source control.\n     “FSH has legs.”\n - Grahame Grieve, FHIR Product Director\n “An immensely useful project.”\n - Richard Kavanagh, Graphnet Health, Board Member HL7 UK and INTEROPen\n “Simply fantastic.”\n - Keith Boone, Informatics Adept at Audacious Inquiry\n “FSH is a joy.”\n - David Hay, “Hay on FHIR” blog\n “Too good to be true! Like a revolution.”\n - Dr. Bertil Reppen, Apertura (HL7 Norway)\n    ","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/","title":"FSH School"},{"body":"\nQuick Start Get started producing FHIR Profiles and Implementation Guides in no time.\n    FHIR Shorthand (FSH) is a domain-specific language for defining the contents of FHIR Implementation Guides (IG). FSH can be created and updated using any text editor. Because it is text, it enables distributed, team-based development using source code control tools such as GitHub.\nHere are three ways to get started:\n1. Do the Tutorials The easiest way to get familiar with FSH is through the hands-on tutorials. The tutorials will show you the end-to-end process of creating an Implementation Guide (IG) using FSH and SUSHI (the FSH compiler).\n2. Start a Project from Scratch If you are starting a brand-new project, follow these steps:\n  Install SUSHI.\n  Set up the directory structure for your project.\n  Create a sushi-config.yaml file\n  Create FSH files containing your content.\n  Run SUSHI or the IG Publisher tool to create your FHIR artifacts and Implementation Guide.\n  3. Transform an Existing Implementation Guide Using GoFSH, you can turn an existing FHIR Implementation Guide into a FSH project automatically. GoFSH instantly translates your StructureDefinitions, value sets, and examples into FHIR Shorthand.\n   ","excerpt":"\nQuick Start Get started producing FHIR Profiles and Implementation …","ref":"/quickstart/","title":"Quick Start"},{"body":"","excerpt":"","ref":"/search/","title":"Search Results"}]